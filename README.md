# unkodb

SQLにする気はないのでsql/driverを実装しない

アドレス(インデックス?)を4byteに固定するので
保持可能なデータ総数は、かなり少ない

DBヘッダ
    先頭??byte  ファイルシグネチャ(?)
    続く2byte   DBヘッダサイズ(シグネチャ含むDBヘッダ全体)
    続く2byte   ファイルフォーマットバージョン番号
    続く4byte   テーブルIDテーブルの先頭エントリーのアドレス(エントリー部内相対アドレス)
    続く4byte   再利用可能エントリー(Tree型で管理)のルートノードのアドレス(エントリー部内相対アドレス)
    続く4byte   エントリー部全体のサイズ
エントリー部
    エントリーが並ぶ(List型やTree型のどちらも混ざって並ぶ、アドレス保持により連結するため混ざって配置されても無問題)
    

エントリーヘッダ
    先頭2byte    エントリーサイズ(ヘッダ含む)(4の倍数のバイト数になるようにする)
    続く2byte    テーブルID

List型エントリー
    エントリーヘッダ
    続く4byte    前のエントリーのアドレス(エントリー部内相対アドレス)
    続く4byte  　次のエントリーのアドレス(エントリー部内相対アドレス)
    以降、テーブルによって定められたカラムデータが並ぶ

Tree型エントリー
    エントリーヘッダ
    続く4byte                左の子のエントリーのアドレス(エントリー部内相対アドレス)
    続く4byte                右の子のエントリーのアドレス(エントリー部内相対アドレス)
    続く4byte                高さ
    キーの型に応じたサイズ   キーの値
    以降、テーブルによって定められたカラムデータが並ぶ



変更ごとに毎度細かいファイル編集が良いかどうかわからん
たとえば適当なチャンク(10KBとか？)に区切って読み書きするのは？
全データをメモリにロードするのは？重すぎる？
全データをメモリにロードするなら普通のデータ構造でもいい気がする

適切なチャンクサイズの設定は難易度高そう
HDDアクセスやOSの読み書き処理の仕組みを知る必要があり
正直、それ調べるの面倒
軽くググったがわからん
雰囲気的にあんま気にしなくてよさそう？
仮にチャンク作るとしたら4KB,8KB,16KBのいずれかがよさそうな雰囲気・・

Goのメモリバッファ(bytes.Buffer)にio.Seekerが実装されてないため
チャンクに対する操作は厳しいかもしれない

Goでプリミティブをbyte列への変換は
encoding/binaryパッケージを使う
(インターフェース経由、なんだよね・・・)

テーブルIDテーブル
および
テーブルIDテーブルのカラム
および
カラムの定義方法
を
決めないと・・・



カラムの型
bool(int32?)
int32
int64
float64
datetime(int64)
固定容量データ(int32,[]byte)
任意容量データ(int32,[]byte)
固定容量文字列(int32,[]byte)(UTF-8)
任意容量文字列(int32,[]byte)(UTF-8)


キーに使える型
int32
int64
datetime(int64)
固定容量文字列(int32,[]byte)(UTF-8)



テーブルに必要な情報(共通?)
 - テーブル名(固定容量文字列)
 - テーブルID
 - データ総数
 - タイプ(Tree/List)
 - (テーブルのタイプ別情報)
 - カラム数(Tree型の場合はキーのカラムは含まない)
 - 各カラムの情報(Tree型の場合はキーのカラムは含まない)
    + カラムの型
    + カラム名(固定容量文字列)
 
テーブルに必要な情報(List型)
 - リスト先頭アイテムの先頭アドレス
 - リスト末尾アイテムの先頭アドレス

テーブルに必要な情報(Tree型)
 - ルートノードアイテムの先頭アドレス
 - キーの型
 - キーの値に割り当てるカラム名(固定容量文字列)





もうTreeタイプだけのAVL木集合でよくね？





Keyの型
counter(int32)
int32
int64
固定長(uint8,[]byte)
固定長(uint8,[]byte(string),UTF-8)

カラムの型
boolean(int32)
int32
int64
固定長(uint8,[]byte)
可変長(int32,[]byte)
固定長(uint8,[]byte(string),UTF-8)
可変長(int32,[]byte(string),UTF-8)


エントリ1セットあたりサイズ上限65500byteくらい(ツリー構成部も含む)
カラム可変長1個あたりの最大サイズ60000byteくらい




DBヘッダ
    先頭??byte  ファイルシグネチャ(?)
    続く2byte   DBヘッダサイズ(シグネチャ含むDBヘッダ全体)
    続く2byte   ファイルフォーマットバージョン番号
    続く4byte   テーブルIDテーブルの先頭エントリーのアドレス(エントリー部内相対アドレス)
    続く4byte   再利用可能エントリー(Tree型で管理)のルートノードのアドレス(エントリー部内相対アドレス)
    続く4byte   エントリー部全体のサイズ
エントリー部
    エントリーが並ぶ(テーブルの区別なく混ざって並ぶ、アドレス保持により連結するため混ざって配置されても無問題)


エントリー
    先頭2byte                エントリーサイズ(4の倍数のバイト数になるようにする)
    続く2byte                サブTreeの高さ
    続く4byte                左の子のエントリーのアドレス(エントリー部内相対アドレス)
    続く4byte                右の子のエントリーのアドレス(エントリー部内相対アドレス)
    キーの型に応じたサイズ   キーの値
    以降、テーブルによって定められたカラムデータが並ぶ


テーブルに必要な情報(共通?)
 - テーブル名(固定容量文字列)
 - データ総数
 - (テーブルのタイプ別情報)
 - ルートノードアイテムの先頭アドレス
 - キーの型
 - キーの値に割り当てるカラム名(固定容量文字列)
 - 最後に挿入されたキーの値 (キーがcounter以外の場合は常に0)
 - カラムの数(キーのカラムは含まない)
 - 各カラムの情報(キーのカラムは含まない)
    + カラムの型
    + カラム名(固定容量文字列)
 

